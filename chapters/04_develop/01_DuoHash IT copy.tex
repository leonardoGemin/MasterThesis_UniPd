\section{DuoHash: la nuova versione di MISSH}
\label{sec:DuoHash}

Il miglioramento definitivo del tool \acs{MISSH} ha preso forma con l'introduzione di una nuova strategia per calcolare l'hashing delle sequenze nucleotidiche, riducendo significativamente il tempo di calcolo e aumentando l'efficienza complessiva del processo. Questo approccio sfrutta l'encoding iniziale\footnote{Nel tool DuoHash è chiamato “encoding" quello che nelle versioni precedenti era chiamato “hash".} e una struttura denominata \verb|Hash| che contiene le variabili per il forward ed il reverse hashing. L'idea di base del nuovo algoritmo è l'utilizzo di tabelle con hash pre-calcolati per velocizzare il processo di calcolo degli hash. Invece di calcolare l'hash per ogni base nucleotidica durante il runtime, vengono utilizzate tabelle di look-up che contengono i valori pre-calcolati per tutte le possibili combinazioni di 4 basi azotate. Questo approccio riduce drasticamente il numero di operazioni necessarie.

\begin{example}
	Per spiegare meglio il concetto, consideriamo un esempio di tabelle di look-up. 
	\begin{center}
		\begin{tabular}{c c c}
			\textbf{sequence} & \textbf{encoding} & \textbf{hashing} \\
			\toprule
			\verb|AAAA| & \verb|00000000| & \verb|0x53EC3F8647623EED| \\
			\verb|CAAA| & \verb|00000001| & \verb|0x3B2DEE31FC53472D| \\
			\verb|GAAA| & \verb|00000010| & \verb|0xB622149EFBEB046D| \\
			\verb|TAAA| & \verb|00000011| & \verb|0xFD19ADB0B6403FFD| \\
			\verb|ACAA| & \verb|00000100| & \verb|0x678CD75D9AFA820D| \\
			\verb|...| & \verb|...| & \verb|...| \\
			\verb|TTTT| & \verb|11111111| & \verb|0x9400B260ACBDFF13| \\
			\bottomrule
		\end{tabular}
	\end{center}
	
	Data la sequenza nucleotidica $x = \texttt{AGGCCCACTGGAAGTTGTAGCCACCG}$ e lo spaced seed \verb|11110111011100111011101111| definito come $Q = \{ 0, 1, 2, 3, 5, 6, 7, 9, 10, 11, 14, 15, 16, 18, 19, 20, 22, 23, 24, 25 \}$, il $Q$-gram $x[0 + Q]$ è calcolato nel seguente modo:
	\begin{center}
		\begin{tabular}{r || l}
			$x$ & \texttt{AGGCCCACTGGAAGTTGTAGCCACCG} \\
			$Q$ & \texttt{11110111011100111011101111} \\
			$x[0 + Q]$ & \texttt{AGGC\ CAC\ GGA\ \ TTG\ AGC\ ACCG} \\
		\end{tabular}
	\end{center}
	
	Il $Q$-gram risultante è $x[0 + Q] = \texttt{AGGCCACGGATTGAGCACCG}$. Il suo encoding, in accordo con \acs{MISSH} e precedenti versioni, è \[ h(x[0 + Q]) = \texttt{1001010001100010111100101001000101101000} \]
	
	Si contano un totale di $k = 5$ gruppi di 8 bit (corrispondenti all'encoding di 4 basi). Ognuno di questi gruppi viene utilizzato come indice per accedere alle tabelle di hash pre-calcolati:
	\begin{center}
		\begin{tabular}{r c c}
			\textbf{i} & \textbf{encoding} & \textbf{hashing} \\
			\toprule
			0 & \verb|01101000| & \verb|0x15609AFAC162C235| \\
			1 & \verb|10010001| & \verb|0x3DA45F3F050E3E0D| \\
			2 & \verb|11110010| & \verb|0x8841C2559987C40B| \\
			3 & \verb|01100010| & \verb|0x8249A46E23AF65F5| \\
			4 & \verb|10010100| & \verb|0x6105665363A7FB2D| \\
			\bottomrule
		\end{tabular}
	\end{center}
	
	L'hashing value viene poi calcolato tramite la seguente formula: \[ \text{hashing} = \bigoplus_{i = 0}^{k - 1} \rol^{k - i - 1} \text{look-up}[i] \] 
	Nel caso in esempio, l'hashing assume il valore \begin{align*}
		\text{hashing} &= \texttt{0x9AFAC162C2351560} \oplus \texttt{0x45F3F050E3E0D3DA} \oplus {} \\
		&\quad {} \oplus \texttt{0x41C2559987C40B88} \oplus \texttt{0x249A46E23AF65F58} \oplus {} \\
		&\quad {} \oplus \texttt{0x6105665363A7FB2D} \\
		&= \texttt{0xDB54441AFF406947} 
	\end{align*}
\end{example}

Per gestire al meglio forward e reverse hashing, e i casi in cui l'ultimo gruppo di 4 basi azotate non sia completamente riempito, le tabelle di look-up sono 8:
\begin{itemize}
	\item \verb|e4_to_fHash| e \verb|e4_to_rHash| per la gestione dei gruppi completi di tutte e 4 le basi;
	\item \verb|e3_to_fHash| e \verb|e3_to_rHash| per la gestione dei gruppi composti da 3 basi;
	\item \verb|e2_to_fHash| e \verb|e2_to_rHash| per la gestione dei gruppi articolati da 2 basi;
	\item \verb|e1_to_fHash| e \verb|e1_to_rHash| per la gestione dei gruppi che hanno solamente 1 base.
\end{itemize}

Ogni tabella adibita alla gestione di gruppi composti da $k$ basi azotate, contiene $4^k$ valori. Per ciascuno di questi valori, sono pre-calcolati anche i corrispondenti shift, evitando operazioni di shift durante il runtime.
Tenendo conto che sono ammessi spaced seed con un peso massimo di 32, e che i valori delle tabelle di look-up sono a gruppi di 4 basi azotate, gli shift possibili sono 8.
Considerando che ogni tabella contiene $4^k$ valori, che per ogni valore sono pre-calcolati anche i corrispondenti 8 shift, e che ogni valore è un numero intero a 64 bits (8 Bytes), ogni tabella richiede uno spazio di memoria pari a $4^{k + 3} \text{ Bytes}$. In totale le tabelle di look-up occupano uno spazio complessivo di $21.25 \text{ kBytes}$\footnote{$1 \text{ Byte} = 8 \text{ bits}$; $1 \text{ kByte} = 1024 \text{ Bytes}$.}. Con le moderne capacità di memoria, lo spazio richiesto per la gestione delle 8 tabelle di look-up è accettabile. Nell'Algoritmo~\ref{alg:DuoHash-lookup-table} è descritto il modo in cui vengono pre-calcolate le tabelle di look-up.

\begin{algorithm}[!ht]
	\caption{DuoHash: look-up tables}
	\label{alg:DuoHash-lookup-table}
	
	\SetKwFunction{FlookupTable}{lookupTable}
	\Fn{\FlookupTable{$k$}}{
		$\mathrm{values} \gets \{ \texttt{0x3c8bfbb395c60474}, \texttt{0x3193c18562a02b4c}, \allowbreak\texttt{0x20323ed082572324}, \texttt{0x295549f54be24456} \}$\;
		\For{$i \gets 0$ \KwTo $4^k$}{
			$\mathrm{fTable}[i][0] \gets 0$\;
			$\mathrm{rTable}[i][0] \gets 0$\;
			\For{$j \gets 0$ \KwTo $k$}{
				$index \gets (i >\!> 2j) \land \texttt{0b11}$\;
				$\mathrm{fTable}[i][0] \gets \mathrm{fTable}[i][0] \oplus \rol^{k - j - 1} \mathrm{values}[index]$\;
				$\mathrm{rTable}[i][0] \gets \mathrm{rTable}[i][0] \oplus \rol^{k - j - 1} \mathrm{values}[4 - 1 - index]$\;
			}
			
			\For{$j \gets 0$ \KwTo $8$}{
				$\mathrm{fTable}[i][j] \gets \rol^{4j} \mathrm{fTable}[i][0]$\;
				$\mathrm{rTable}[i][j] \gets \rol^{4j} \mathrm{rTable}[i][0]$\;
			}
		}
		\KwRet{$\langle \mathrm{fTable}, \mathrm{rTable} \rangle$}\;
	}
\end{algorithm}




Il punto di partenza del nuovo algoritmo è la produzione del solo encoding della sequenza nucleotidica, ovvero quello che nelle versioni precedenti del software era chiamato “hashing value". Questo encoding viene salvato all'interno di una struttura denominata \verb|Hash|, che contiene anche due variabili predisposte per il forward e per il reverse hash. Questi ultimi vengono calcolati solo successivamente, sfruttando la funzione \verb|getHashes| appositamente ottimizzata. La funzione, come illustrato nell'Algoritmo~\ref{alg:DuoHash}, riceve due parametri: la struttura \verb|Hash| ed il valore $s(Q)$. La variabile \verb|encoding| viene temporaneamente scomposta in byte, ognuno dei quali rappresenta l'encoding di 4 basi azotate. Utilizzando il valore del byte come indice, la funzione accede ad una serie di tabelle di valori pre-calcolati, come descritto nel precedente paragrafo.

\begin{algorithm}[!ht]
	\caption{DuoHash: getHashes function}
	\label{alg:DuoHash}
	
	\SetKwFunction{FgetHashes}{getHashes}
	\Fn{\FgetHashes{$Hash$, $s(Q)$}}{
		$bytes \gets s(Q) / 4$\tcp*{$Hash = \langle encoding, forward, reverse \rangle$}
		\For{$i \gets 0$ \KwTo $bytes$}{
			$curr\_byte \gets i$-th byte of $encoding$\;
			$forward \gets forward \oplus e4\_to\_fHash[curr\_byte][bytes - i - 1]$\;
			$reverse \gets reverse \oplus e4\_to\_rHash[curr\_byte][i]$\;
		}
		
		\If{$s(Q) \bmod 4 \neq 0$}{
			$curr\_byte \gets bytes$-th byte of $encoding$\;
			$forward \gets \rol^{s(Q) \bmod 4} forward$\;
			
			\If{$s(Q) \bmod 4 = 3$}{
				$forward \gets forward \oplus e3\_to\_fHash[curr\_byte][0]$\;
				$reverse \gets reverse \oplus e3\_to\_rHash[curr\_byte][bytes]$\;
			}
			\ElseIf{$s(Q) \bmod 4 = 2$}{
				$forward \gets forward \oplus e2\_to\_fHash[curr\_byte][0]$\;
				$reverse \gets reverse \oplus e2\_to\_rHash[curr\_byte][bytes]$\;
			}
			\ElseIf{$s(Q) \bmod 4 = 1$}{
				$forward \gets forward \oplus e1\_to\_fHash[curr\_byte][0]$\;
				$reverse \gets reverse \oplus e1\_to\_rHash[curr\_byte][bytes]$\;
			}
		}
	}
\end{algorithm}

Questa soluzione è stata sviluppata per affrontare alcune delle limitazioni delle tecniche precedenti utilizzate in MISSH, che sebbene efficaci, presentavano margini di miglioramento in termini di efficienza computazionale. La nuova strategia si basa sull'idea di evitare il calcolo ripetitivo degli stessi valori e sfruttare invece una tabella di look-up pre-computata, che riduce drasticamente il numero di operazioni necessarie per ottenere gli hash desiderati. La funzione "getHashes" è stata implementata per sfruttare al massimo questa ottimizzazione, garantendo che i valori necessari siano sempre prontamente disponibili senza doverli ricalcolare ogni volta. L'approccio adottato tiene anche conto della necessità di gestire le sequenze di lunghezza variabile in modo efficiente. Infatti, la gestione di $s(Q) \bmod 4$ consente di trattare casi in cui la lunghezza della sequenza non sia un multiplo esatto di 4 basi azotate. 

Un ulteriore vantaggio significativo di questa implementazione è la facilità con cui si può modificare la funzione di hashing. Grazie alla struttura modulare, è possibile aggiornare la funzione \verb|getHashes| per passare da una rolling hash function a qualsiasi altra funzione di hashing, senza necessità di modificare altre parti del codice. Questo rende il tool estremamente flessibile e facilmente adattabile a nuove esigenze o algoritmi di hashing, migliorando la sua longevità e utilità. La possibilità di cambiare facilmente la funzione di hashing è resa possibile dal fatto che l'encoding, calcolato inizialmente da \acs{MISSH}, fornisce una base robusta e flessibile su cui si possono applicare diverse strategie di hashing. L'integrazione di questa nuova funzione di hashing con le altre componenti di MISSH ha richiesto un'attenta considerazione dell'architettura complessiva del tool. La decisione di produrre inizialmente solo l'encoding forward e di rimandare il calcolo degli hash forward e reverse a una fase successiva è stata presa per massimizzare l'efficienza e ridurre il carico computazionale iniziale. Questo approccio permette di accumulare tutti gli encoding necessari prima di procedere con il calcolo degli hash, ottimizzando così l'uso delle risorse e migliorando la velocità complessiva del processo. Inoltre, la scelta di utilizzare una struttura \verb|Hash| per contenere sia l'encoding che gli hash forward e reverse ha reso il codice più modulare e facile da manutenere. Questa struttura permette di isolare il calcolo degli hash da altre operazioni, facilitando la debug e l'eventuale aggiornamento del codice. La funzione \verb|getHashes| è stata progettata per essere altamente efficiente, riducendo al minimo il numero di operazioni necessarie e sfruttando al massimo le capacità di calcolo delle moderne CPU.

L'approccio innovativo adottato in questa versione di MISSH rappresenta un significativo passo avanti rispetto alle tecniche precedentemente utilizzate. La combinazione di una struttura dati ottimizzata, l'uso di tabelle di look-up pre-computate e l'efficiente gestione dei remainder consente di ottenere un notevole miglioramento delle prestazioni, rendendo il tool più competitivo e adatto a gestire grandi quantità di dati con maggiore velocità e precisione. I benefici di questo approccio saranno ulteriormente esplorati nei capitoli successivi, dove verranno presentati i risultati dei test di performance e le comparazioni con altri strumenti, dimostrando l'efficacia e la superiorità della nuova strategia adottata.
