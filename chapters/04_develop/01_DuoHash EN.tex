\section{DuoHash: the new version of MISSH}
\label{sec:DuoHash}

The final improvement of the \acs{MISSH} tool took shape with the introduction of a new strategy for calculating the hashing of nucleotide sequences, significantly reducing the calculation time and increasing the overall efficiency of the process. This approach exploits the initial encoding and a structure called \verb|Hash| to optimise forward and reverse hash calculations. The version of \acs{MISSH} from which the improvement started already includes some previous optimisations, such as the modification of the \verb|char_to_int| function seen earlier.

The starting point of the new algorithm is the production of only the forward encoding of the nucleotide sequence. This encoding is stored within a structure called \verb|Hash|, which also contains two variables set for the forward and reverse hashes. The latter are calculated only later, using the specially optimised \verb|getHashes| function. The function, as illustrated in the Algorithm~\ref{alg:DuoHash_getHashes}, receives two parameters: the structure \verb|Hash| and the value $s(Q)$. The variable \verb|encoding|, of type \verb|uint64_t|\footnote{In the programming language used by the tool, \texttt{C++}, this corresponds to a 64-bit integer (or 8 bytes).}, is broken down into 1-byte chunks, representing the encoding of 4 nitrogen bases. Using the value of the chunk as an index, the function accesses a table of pre-calculated values, \verb|e4_to_fHash|\footnote{The tables \texttt{e4\_to\_fHash} and the like give access to the pre-calculated values by means of two indices in this way: the first index corresponds to the encoding value of the 4 nucleotide characters, the second index is indicative of the shift required to correctly position the contribution in the hashing value.} or \verb|e4_to_rHash|, which contains all the possible $4^4 = 256$ values that the 1-byte chunks can take. For each of the 256 values, the corresponding shifts have also been pre-calculated, a procedure that avoids having to perform the shift operation at runtime. For cases in which the last byte of the \verb|encoding| variable contains less than 4 nitrogen bases, specific instructions and tables of pre-calculated values have been prepared.

\begin{algorithm}[!ht]
	\caption{DuoHash: getHashes function}
	\label{alg:DuoHash_getHashes}
	
	\SetKwFunction{FgetHashes}{getHashes}
	\Fn{\FgetHashes{$Hash$, $s(Q)$}}{
		$k \gets \lfloor s(Q) / 4 \rfloor$\tcp*{$Hash = \langle encoding, forward, reverse \rangle$}
		\For{$i \gets 0$ \KwTo $k$}{
			$curr\_encoding\_byte \gets i$-th byte of $encoding$\;
			$forward \gets forward \oplus e4\_to\_fHash[curr\_encoding\_byte][k - 1 - i]$\;
			$reverse \gets reverse \oplus e4\_to\_rHash[curr\_encoding\_byte][i]$\;
		}
		
		\If{$s(Q) \bmod 4 \neq 0$}{
			$curr\_encoding\_byte \gets k$-th byte of $encoding$\;
			$forward \gets \rol^{s(Q) \bmod 4} forward$\;
			
			\If{$s(Q) \bmod 4 = 3$}{
				$forward \gets forward \oplus e3\_to\_fHash[curr\_encoding\_byte][0]$\;
				$reverse \gets reverse \oplus e3\_to\_rHash[curr\_encoding\_byte][k]$\;
			}
			\ElseIf{$s(Q) \bmod 4 = 2$}{
				$forward \gets forward \oplus e2\_to\_fHash[curr\_encoding\_byte][0]$\;
				$reverse \gets reverse \oplus e2\_to\_rHash[curr\_encoding\_byte][k]$\;
			}
			\ElseIf{$s(Q) \bmod 4 = 1$}{
				$forward \gets forward \oplus e1\_to\_fHash[curr\_encoding\_byte][0]$\;
				$reverse \gets reverse \oplus e1\_to\_rHash[curr\_encoding\_byte][k]$\;
			}
		}
	}
\end{algorithm}

This solution was developed to address some of the limitations of the previous techniques used in \acs{MISSH}, which, although effective, had room for improvement in terms of computational efficiency. The new strategy is based on the idea of avoiding the repetitive calculation of the same values and instead exploiting a pre-computed lookup table, which drastically reduces the number of operations required to obtain the desired hashes. The \verb|getHashes| function has been implemented to take full advantage of this optimisation, ensuring that the necessary values are always readily available without having to recalculate them each time. The approach taken also takes into account the need to handle variable-length sequences efficiently. Indeed, handling $s(Q) \bmod 4$ makes it possible to deal with cases where the length of the sequence is not an exact multiple of 4 nitrogenous bases.

A further significant advantage of this implementation is the ease with which the hashing function can be modified. Thanks to the modular structure, it is possible to update the \verb|getHashes| function to switch from a rolling hash function to any other hashing function, without the need to modify other parts of the code. This makes the tool extremely flexible and easily adaptable to new requirements or hashing algorithms, improving its longevity and usefulness. The possibility of easily changing the hashing function is made possible by the fact that the encoding, initially calculated by \acs{MISSH}, provides a robust and flexible base on which different hashing strategies can be applied.

The integration of this new hashing function with the other components of \acs{MISSH} required careful consideration of the overall architecture of the tool. The decision to initially produce only the forward encoding and to postpone the calculation of the forward and reverse hashes to a later stage was taken in order to maximise efficiency and reduce the initial computational load. This approach allows all the necessary encodings to be accumulated before proceeding with the calculation of the hashes, thus optimising the use of resources and improving the overall speed of the process.

Furthermore, the choice of using a \verb|Hash| structure to contain both the encoding and the forward and reverse hashes made the code more modular and easier to maintain. This structure allows the calculation of the hashes to be isolated from other operations, making it easier to debug and update the code if necessary. The \verb|getHashes| function has been designed to be highly efficient, minimising the number of operations required and making maximum use of the calculation capabilities of modern CPUs.

The innovative approach adopted in this version of \acs{MISSH} represents a significant step forward compared to previously used techniques. The combination of an optimised data structure, the use of pre-computed look-up tables and the efficient management of remainders results in a significant improvement in performance, making the tool more competitive and suitable for handling large amounts of data with greater speed and accuracy. The benefits of this approach will be further explored in the following chapters, where the results of performance tests and comparisons with other tools will be presented, demonstrating the effectiveness and superiority of the new strategy adopted.
