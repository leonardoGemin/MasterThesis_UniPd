\section{DuoHash: nuove funzionalità}
\label{sec:DuoHash-newFunctionality}

L'ultimo aggiornamento del tool MISSH, denominato DuoHash, introduce una serie di nuove funzionalità che migliorano significativamente la flessibilità e l'efficienza del processo di hashing delle sequenze nucleotidiche. Le due principali novità sono la possibilità di modificare facilmente la funzione di hash e l'implementazione della funzione \verb|getSpacedKmer|, che converte gli encoding in sequenze nucleotidiche e le salva in un file FASTA, creando un dataset utilizzabile da tool terzi come JellyFish. Questi miglioramenti rendono DuoHash uno strumento estremamente versatile e potente per l'analisi delle sequenze genomiche.

Uno dei punti di forza di DuoHash è la possibilità di cambiare facilmente la funzione di hash senza compromettere l'efficienza del tool. La nuova struttura di DuoHash è progettata in modo tale che la funzione di hashing possa essere sostituita agendo principalmente sulla funzione \verb|getHashes|. Questo permette di adattare rapidamente il tool a diverse esigenze di calcolo e algoritmi di hashing, mantenendo sempre la stessa base di valori encoding calcolati da \acs{MISSH}. L'implementazione attuale di DuoHash utilizza una rolling hash function, che sfrutta la pre-computazione di valori e operazioni bitwise per garantire un calcolo efficiente. Tuttavia, grazie alla modularità del sistema, è possibile implementare altre funzioni di hash con poche modifiche al codice. Ad esempio, si potrebbe sostituire la rolling hash function con una funzione di hash basata sull'algoritmo di \ac{FNV} \cite{fowler2005fnv}, nota per la sua semplicità ed efficienza. L'Algoritmo~\ref{alg:DuoHash_getHashes_fnv} descrive una possibile implementazione della funzione di hash \acs{FNV}-1A.

\begin{algorithm}[!ht]
	\caption{DuoHash: getHashes function with \acs{FNV}-1A hash function.}
	\label{alg:DuoHash_getHashes_fnv}
	
	\SetKwFunction{FgetHashes}{getHashes}
	\Fn{\FgetHashes{$Hash$, $s(Q)$}}{
		$k \gets \lceil s(Q) / 4 \rceil$\tcp*{$Hash = \langle encoding, forward, reverse \rangle$}
		$forward \gets \mathrm{FNV\_offset\_basis}$\;
		$reverse \gets \mathrm{FNV\_offset\_basis}$\;
		
		\For{$i \gets 0$ \KwTo $k$}{
			$forward \gets (forward \oplus i$-th byte of $encoding) \cdot \mathrm{FNV\_prime}$\;
			$reverse \gets (reverse \oplus (k - 1 - i)$-th byte of $encoding) \cdot \mathrm{FNV\_prime}$\;
		}
	}
\end{algorithm}

\subsubsection*{Creazione di file FASTA}
Oltre alla flessibilità della funzione di \verb|getHashes|, DuoHash introduce la funzione \verb|getSpacedKmer|, riportata nell'Algoritmo~\ref{alg:DuoHash_getSpacedKmer}. Questa funzione converte gli encoding in sequenze nucleotidiche e le salva in un file FASTA, rendendo possibile l'utilizzo dei dati con tool terzi come JellyFish \cite{marcais2011jellyfish}, un programma utilizzato per il conteggio veloce dei k-mer nelle sequenze di \acs{DNA}.

\begin{algorithm}[!ht]
	\caption{DuoHash: getSpacedKmer function}
	\label{alg:DuoHash_getSpacedKmer}
	
	\SetKwFunction{FgetSpacedKmer}{getSpacedKmer}
	\Fn{\FgetSpacedKmer{$Hash$, $s(Q)$}}{
		$k \gets \lfloor s(Q) / 4 \rfloor$\tcp*{$Hash = \langle encoding, spacedKmer \rangle$}
		\For{$i \gets 0$ \KwTo $k$}{
			$curr\_encoding\_byte \gets i$-th byte of $encoding$\;
			$curr\_spacedKmer\_word$ is the $i$-th word of 32bits of $spacedKmer$\;
			$curr\_spacedKmer\_word \gets e4\_to\_char[curr\_encoding\_byte]$\;
		}
		
		\If{$s(Q) \bmod 4 \neq 0$}{
			$curr\_encoding\_byte \gets k$-th byte of $encoding$\;
			$curr\_spacedKmer\_word$ is the $k$-th word of 32bits of $spacedKmer$\;
			
			\If{$s(Q) \bmod 4 = 3$}{
				$curr\_spacedKmer\_word \gets e3\_to\_char[curr\_encoding\_byte]$\;
			}
			\ElseIf{$s(Q) \bmod 4 = 2$}{
				$curr\_spacedKmer\_word \gets e2\_to\_char[curr\_encoding\_byte]$\;
			}
			\ElseIf{$s(Q) \bmod 4 = 1$}{
				$curr\_spacedKmer\_word \gets e1\_to\_char[curr\_encoding\_byte]$\;
			}
		}
		
		$spacedKmer[k] = \mathrm{'\backslash0'}$\;
	}
\end{algorithm}

Questa funzione lavora scomponendo la variabile encoding in chunk da 1 byte e convertendoli in caratteri nucleotidici utilizzando tabelle di lookup (\verb|e4_to_char|, \verb|e3_to_char|, ecc.). Il risultato è una sequenza nucleotidica \verb|spacedKmer| che viene poi salvata in un file FASTA.
