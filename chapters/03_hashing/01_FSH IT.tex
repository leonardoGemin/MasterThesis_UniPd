\section{FSH}
\label{sec:FSH}

Il \ac{FSH} \cite{girotto2018fsh} è un algoritmo sviluppato per aumentare l'efficienza del calcolo degli hash per spaced seed nelle applicazioni bioinformatiche. Questo approccio sfrutta le somiglianze tra i valori hash di spaced seed calcolati in posizioni vicine all'interno di una sequenza di input attraverso una tecnica di programmazione dinamica mirata alla riduzione del numero di simboli letti e codificati nel processo di calcolo degli hash. In questo modo si ottiene una velocità di eleborazione maggiore rispetto ai metodi tradizionali.

L'encoding dei simboli, un processo di trasformazione dei dati in un formato diverso utilizzando uno schema di codifica specifico, è essenziale per la rappresentazione numerica delle sequenze di DNA o proteine. La codifica utilizzata da \acs{FSH} è basata sulla funzione \[ encode(\mathrm{ch}): \mathcal{A} \to \{0, 1\}^{\log_2 |\mathcal{A}|} \] e le quattro basi azotate sono mappati come segue: \[ \begin{matrix}
	encode(\texttt{A}) = \texttt{00}  &  encode(\texttt{C}) = \texttt{01} \\
	encode(\texttt{G}) = \texttt{10}  &  encode(\texttt{T}) = \texttt{11} 
\end{matrix} \]
Questa codifica è necessaria per la successiva applicazione delle funzioni di hashing, in quanto trasforma i dati della sequenza in un formato numerico adatto all'elaborazione computazionale.


\begin{example}
	Seguendo l'esempio del capitolo precedente, è possibile calcolare l'encoding di tutti i simboli del $Q$-gram $x[0 + Q]$ in questo modo:
	
	{
		\centering
		\begin{tabular}{r | ccccc}
			$x[0 + Q]$ & \texttt{C} & \texttt{T} & \texttt{G} & \texttt{C} & \texttt{G} \\
			$encode(\mathrm{ch})$ & \texttt{01} & \texttt{11} & \texttt{10} & \texttt{01} & \texttt{10} 
		\end{tabular}
		
	}
\end{example}

Nel paper di \acs{FSH}, gli autori hanno considerato la Rabin-Karp rolling hash \cite{cormen2009introduction}, così definita: \[ h\left( x[i + Q] \right) = \bigvee_{k \in Q} \left( encode(x_{i + k}) <\!< m(k) \cdot \log_2 |\mathcal{A}| \right), \] dove \[ m(k) = \left| \{ i \in Q \; | \; i < k \} \right| \] è il numero di shift che devono essere applicati al $k$-esimo simbolo.

\begin{example}
	In relazione all'esempio del capitolo precedente, sono riportati i passi per il calcolo dell'encoding del $Q$-gram $x[0 + Q]$:
	
	{
		\centering
		\begin{tabular}{r | ccccccccccc}
			$x$ & \texttt{C} & \texttt{T} & \texttt{T} & \texttt{G} & \texttt{T} & \texttt{C} & \texttt{G} & \texttt{T} & \texttt{T} & \texttt{G} & \texttt{A} \\
			$Q$ & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{1} \\
			$m$ & 0 & 1 & 1 & 2 & 3 & 3 & 4 \\
			$x[0 + Q]$ & \texttt{C} & & \texttt{T} & \texttt{G} & & \texttt{C} & \texttt{G} \\
			$encode(x[0 + Q])$ & \texttt{01} & & \texttt{11} & \texttt{10} & & \texttt{01} & \texttt{10} 
		\end{tabular}
		
	}

	E quindi per il calcolo dell'hashing value ad esso riferito:
	\begin{align*}
		h\left( x[0 + Q] \right) &= (\texttt{01} <\!< 0) \vee (\texttt{11} <\!< 2) \vee (\texttt{10} <\!< 4) \vee {} \\
		&\qquad {} \vee (\texttt{01} <\!< 6) \vee (\texttt{10} <\!< 8)\\
		&= \texttt{1001101101} 
	\end{align*}
	
	Allo stesso modo, gli hashing values per i restanti $Q$-grams sono: \[ \begin{matrix}
		x[1 + Q] = \texttt{TGTGT} & h(x[1 + Q]) = \texttt{1110111011} \\
		x[2 + Q] = \texttt{TTCTT} & h(x[2 + Q]) = \texttt{1111011111} \\
		x[3 + Q] = \texttt{GCGTG} & h(x[3 + Q]) = \texttt{1011100110} \\
		x[4 + Q] = \texttt{TGTGA} & h(x[4 + Q]) = \texttt{0010111011}
	\end{matrix} \]
\end{example}

È, ora, possibile definire l'insieme degli hashing values di una stringa $x$ dato uno spaced seed $Q$: \[ \mathcal{H}(x, Q) = \left\langle h(x[0 + Q]), h(x[1 + Q]), \dots, h(x[n - 1 + Q]) \right\rangle, \] dove $n = |x| - s(Q) + 1$ è il numero di tutti i $Q$-gram di $x$.

In accordo con gli autori di \acs{FSH}, lo scopo è quello di minimizzare il numero di volte che un simbolo necessita di essere letto e codificato per il calcolo di $\mathcal{H}(x, Q)$.


L'idea è di riutilizzare parte degli hash precedenti per velocizzare il calcolo del nuovo valore. È possibile introdurre una nuova definizione: \[ \mathcal{C}_j = \{ k \in Q \; | \; k + j \in Q \wedge m(k) = m(k + j) - m(j) \}. \] $\mathcal{C}_j$ è l'insieme delle posizioni di $Q$ che, dopo $j$ shifts, appartengono ancora a $Q$, con la proprietà che entrambe le posizioni $k$ e $k + j$ appartengono a $Q$ e sono separate da $j - 1$ caratteri \texttt{1} (non necessariamente consecutivi). In altre parole, se si sta calcolando $h(x[i + Q])$, $\mathcal{C}_j$ contiene l'insieme di posizioni che possono essere recuperate dal valore $h(x[i - j + Q])$ calcolato in precedenza.

\begin{example}
	Avendo già calcolato il valore $h(x[0 + Q])$, è venuto il momento di calcolare $h(x[1 + Q])$. In questo esempio viene mostrato il calcolo di $\mathcal{C}_1$.
	
	{
		\centering
		\begin{tabular}{r | cccccccc}
			$k$ & & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
			\midrule
			$Q$ & & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{1} \\
			$m(k)$ & & 0 & 1 & 1 & 2 & 3 & 3 & 4 \\
			\midrule
			$Q <\!< 1$ & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{1} & \\
			$m(k + 1)$ & 0 & 1 & 1 & 2 & 3 & 3 & 4 & \\
			\midrule
			$m(k)$ & & 0 & 1 & 1 & 2 & 3 & 3 & 4 \\
			$m(k + 1) - m(1)$ & -1 & 0 & 0 & 1 & 2 & 2 & 3 & \\
			$m(k) = m(k + 1) - m(1)$ & & T & F & T & T & F & T & \\
			\midrule
			$Q$ & & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{1} \\
			$Q <\!< 1$ & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{1} & \\
			$(k \in Q) \wedge (k + 1 \in Q)$ & & F & F & T & F & F & T & \\
			\midrule
			$\mathcal{C}_1$ & & & & 2 & & & 5 & \\
		\end{tabular}
	
	}
	
	I simboli alle posizioni $\mathcal{C}_1 = \{ 2, 5 \}$ dell'hash $h(x[1 + Q])$ sono già stati codificati nell'hash $h(x[0 + Q])$ ed è possibile riutilizzarli senza doverli calcolare \emph{ex-novo} di volta in volta. Per completare il calcolo dell'hash $h(x[1 + Q])$ è necessario calcolare i restanti $|Q| - |\mathcal{C}_1| = 3$ simboli, che devono essere lette da $x$ nelle posizioni $i + k$, dove $i = 1$ e $k \in Q \setminus \mathcal{C}_1 = \{ 0, 3, 6 \}$.
	
	{
		\centering
		\begin{tabular}{r | ccccccccccc}
			$x$ & \texttt{C} & \texttt{T} & \texttt{T} & \texttt{G} & \texttt{T} & \texttt{C} & \texttt{G} & \texttt{T} & \texttt{T} & \texttt{G} & \texttt{A} \\
			$x[0 + Q]$ & \texttt{C} & & \texttt{T} & \texttt{G} & & \texttt{C} & \texttt{G} \\
			$\mathcal{C}_1$ & & & & 2 & & & 5 & \\
			$Q \setminus \mathcal{C}_1$ & & 0 & & & 3 & & & 6 \\
			$x[1 + Q]$ & & \texttt{T} & & \texttt{G} & \texttt{T} & & \texttt{G} & \texttt{T} \\
		\end{tabular}
		
	}
	
	Per completezza sono riportati tutti i valori di $\mathcal{C}_j$: \begin{align*}
		\mathcal{C} &= \left\langle \mathcal{C}_1, \mathcal{C}_2, \dots, \mathcal{C}_7 \right\rangle \\
		&= \left\langle \{2, 5\}, \{0, 3\}, \{0, 2, 3\}, \{2\}, \{0\}, \{0\} \right\rangle
	\end{align*}
\end{example}

Per ottimizzare il riutilizzo di parte dei precedenti hash è necessario minimizzare il numero di volte che un simbolo deve essere letto e codificato. È sufficiente, perciò, trovare il valore $j$ che massimizza $|\mathcal{C}_j|$, e questo è risolvibile con la funzione \[ ArgBH(k) = \argmax_{j \in \{ 1, 2, \dots, k \}} |\mathcal{C}_j|. \] Avendo già calcolato i precedenti $j$ hashes, il miglior hashing value può essere trovato alla posizione $j - ArgBH(j)$. Questo produrrà un risparmio in termini di simboli che non devono essere nuovamente letti e codificati pari a $|\mathcal{C}_{ArgBH(j)}|$. Seguendo le osservazioni fatte finora è possibile calcolare tutti gli hashing values $\mathcal{H}(x, Q)$ utilizzando la seguente programmazione dinamica:

\begin{algorithm}[H]
	\caption{FSH: Fast Spaced Seed Hashing}
	\label{alg:FSH}
	\For{$i \gets 0$ \KwTo $|x| - s(Q)$}{
		\If{$(i = 0)$}{
			$h_0 \gets \text{compute } h(x[0 + Q])$\;
		}
		\ElseIf{$i < s(Q) - 1$}{
			$h_i \gets h_{i - ArgBH(i)} >\!> m(ArgBH(i)) \cdot \log_2 |\mathcal{A}|$\;
			\ForAll{$k \in Q \setminus \mathcal{C}_{ArgBH(i)}$}{
				insert $encode(x_{i + k})$ at position $m(k) \cdot \log_2 |\mathcal{A}|$ of $h_i$\;
			}
		}
		\Else{
			$h_i \gets h_{i - ArgBH(s(Q) - 1)} >\!> m(ArgBH(s(Q) - 1)) \cdot \log_2 |\mathcal{A}|$\;
			\ForAll{$k \in Q \setminus \mathcal{C}_{ArgBH(s(Q) - 1)}$}{
				insert $encode(x_{i + k})$ at position $m(k) \cdot \log_2 |\mathcal{A}|$ of $h_i$\;
			}
		}
	}
\end{algorithm}

Viene fornito anche un secondo algoritmo, Algorithm~\ref{alg:FMSH}, utilizzabile nel caso in cui si lavori con più di uno spaced seed. L'utilizzo di più spaced seed incrementa la sensibilità \cite{leimeister2014fast} e, quindi, merita un approccio dedicato capace di incrementare lo speed-up dell'algoritmo.

Sia $S = \{ s_0, s_1, \dots, s_{n - 1} \}$ l'insieme di $n$ spaced seed, tutti della stessa lunghezza $s(Q)$. È possibile calcolare, per ogni spaced seed $s_j$ il suo vettore $m_j(k)$ come descritto in precedenza. Per poter comparare un dato spaced seed $s_j$ con tutti gli altri spaced seed è necessario ridefinire l'insieme $\mathcal{C}_j$ come segue: \[ \mathcal{C}_j^{y,\; z} = \{ k \in s_y \; | \; k + j \in s_z \wedge m_y(k) = m_z(k + j) - m_z(j) \}. \] In questa nuova definizione $\mathcal{C}_j^{y,\; z}$ valuta il numero di simboli in comune tra il seed $s_y$ ed il $j$-esimo shift del seed $s_z$. In modo simile, è necessario ridefinire la funzione $ArgBH(k)$ come segue: \[ ArgBSH(y, k) = \argmax_{z \in \{ 0, 1, \dots, n - 1 \},\; j \in \{ 1, 2, \dots, k \}} |\mathcal{C}_j^{y,\; z}|. \] $ArgBSH(y, k)$ ritorna, per il seed $s_y$, la coppia di indici $(z, p)$ che rappresentano il miglior seed $s_z$ e il miglior hash $p$. L'algoritmo viene modificato come segue:

\begin{algorithm}[H]
	\caption{FMSH: Fast Multiple Spaced Seed Hashing}
	\label{alg:FMSH}
	\For{$i \gets 0$ \KwTo $|x| - s(Q)$}{
		\For{$j \gets 0$ \KwTo $n - 1$}{
			\If{$(i = 0)$}{
				$h_{0, j} \gets \text{compute } h(x[0 + s_j])$\;
			}
			\ElseIf{$i < s(Q) - 1$}{
				$(z, p) \gets ArgBSH(j, i)$\;
				$h_{i, j} \gets h_{i - p, z} >\!> m_z(p) \cdot \log_2 |\mathcal{A}|$\;
				\ForAll{$k \in s_j \setminus \mathcal{C}_p^{j, z}$}{
					insert $encode(x_{i + k})$ at position $m_j(k) \cdot \log_2 |\mathcal{A}|$ of $h_{i, j}$\;
				}
			}
			\Else{
				$(z, p) \gets ArgBSH(j, s(Q) - 1)$\;
				$h_{i, j} \gets h_{i - p, z} >\!> m_z(p) \cdot \log_2 |\mathcal{A}|$\;
				\ForAll{$k \in s_j \setminus \mathcal{C}_p^{j, z}$}{
					insert $encode(x_{i + k})$ at position $m_j(k) \cdot \log_2 |\mathcal{A}|$ of $h_{i, j}$\;
				}
			}
		}
	}
\end{algorithm}

Sfruttando la somiglianza tra i valori hash delle semi distanziati in posizioni adiacenti, \acs{FSH} riduce il numero di letture e codifiche necessarie. Questa ottimizzazione porta a un incremento della velocità fino a 5.3 volte, a seconda della struttura e della complessità del seme distanziato utilizzato. Inoltre, la capacità dell'algoritmo di riutilizzare i simboli già letti e di calcolare rapidamente gli hash per semi multipli aumenta la sensibilità e l'efficienza complessiva delle applicazioni bioinformatiche. Questo rende \acs{FSH} particolarmente vantaggioso in scenari che richiedono un confronto rapido e accurato di grandi sequenze biologiche, dimostrando la sua rilevanza e potenzialità in ambiti di ricerca avanzata.
