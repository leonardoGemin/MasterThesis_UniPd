\section{ntHash \& ntHash2: Recursive (Spaced Seed) Hashing for Nucleotide Seqences}
\label{sec:ntHash2}

The method of ntHash \cite{mohamadi2016ntHash} is based on a recursive function, known as a rolling hash function, which calculates the hash value of the current $k$-mer $h_i$ from the hash value of the previous $k$-mer $h_{i - 1}$ via a recursive formula. To initialise the hash calculation, the first $k$-mer is calculated as follows: \[ h_0 = \bigoplus_{j = 0}^{k - 1} \rol^{k - 1 - j} h(x[j]). \] In this formula, $\rol^j(\cdot)$ is a left-cyclic rotation, $\oplus$ is the exclusive OR (XOR) operator, and $h(\cdot)$ is a seed table where the nucleotide characters, $\Sigma = \{ \texttt{A}, \texttt{C}, \texttt{G}, \texttt{T} \}$, are assigned to different 64-bit random integers.

The hash value of each successive $k$-mer is calculated recursively: \begin{align*}
	h_i &= f(h_{i - 1}, x[i + k - 1], x[i - 1]) \\
	&= \rol^1 h_{i - 1} \oplus \rol^0 h(x[i + k - 1]) \oplus \rol^k h(x[i - 1])
\end{align*}

The time complexity of ntHash is $O(k + |x|)$, in contrast to the $O(k \cdot |x|)$ complexity of conventional hash functions.

To calculate the hash values of the inverse complementary sequences of a $k$-mer, ntHash uses a seed table that includes the integers corresponding to the complementary bases, allowing efficient calculation without actually inverting the input sequence: \[ h_i^{'} = \begin{dcases*}
	\bigoplus_{j = 0}^{k - 1} \rol^{j} h((x[j] + d) & \quad if $i = 0$ \\
	\ror^1 h_{i - 1}^{'} \oplus \rol^{k - 1} h(x[i + k - 1] + d) \oplus \ror^1 h(x[i - 1] + d) & \quad otherwise
\end{dcases*} \] where $d$ is the offset of the complementary bases in the seed table. This property makes ntHash extremely useful in applications requiring the handling of complementary sequences.


With the introduction of ntHash2 \cite{kazemi2022ntHash2}, the algorithm was further improved to handle spaced seeds. One of the main improvements in ntHash2 is the introduction of the rotation function, $\srol^j(\cdot)$, which splits a 64-bit word into subwords $w_0,\allowbreak w_1,\allowbreak \dots,\allowbreak w_{n-1}$-bit long ($\sum w_i = 64$ and $\gcd(w_i, w_j) = 1$ $\forall i,\; j$), rotates the subwords separately and combines the results. The periodicity of the split rotation is equal to $\lcm(w_0, w_1, \dots, w_{n - 1})$, making it more suitable for longer $k$-mer lengths. Furthermore, to improve the uniform distribution of hashes, ntHash2 defines the canonical hash value of each seed as the sum of the forward hash and the reverse hash, replacing the old version that used the minimum between the two values.

The main innovation of ntHash2 is the method for hashing spaced seeds. First of all, the definition of a block is given, which is a sub-sequence of $Q$ consisting of consecutive \texttt{1} characters, bounded by the \texttt{0} character or the edges of the spaced seed. To compute the hash value for the first $s(Q)$ characters, we iterate over block intervals and include the characters using $\srol^j(\cdot)$ and XOR operations with time complexity $O(|Q|)$. Subsequent hashes are generated by removing and including characters based on block indices, with complexity $O(|B|)$. For faster calculation, ntHash2 redefines blocks as traits of \texttt{0} if the number of expected XOR operations is less by excluding \texttt{0} from the hash value.

The function that calculates the hashing value is redefined according to this formula: \[ h_i = \begin{dcases*}
	\bigoplus_{j = 0}^{k - 1} \rol^{k - 1 - j} h(x[j]) & \quad if $i = 0$ \\
	\srol^1 h_{i - 1} \oplus \srol^0 h(x[i + k - 1]) \oplus \srol^k h(x[i - 1]) & \quad otherwise
\end{dcases*} \]

For the hashing value of the reverse complement, however, the updated formula is as follows: \[ h_i^{'} = \begin{dcases*}
	\bigoplus_{j = 0}^{k - 1} \srol^{j} h((x[j] + d) & \quad if $i = 0$ \\
	\sror^1 h_{i - 1}^{'} \oplus \srol^{k - 1} h(x[i + k - 1] + d) \oplus \sror^1 h(x[i - 1] + d) & \quad otherwise
\end{dcases*} \]

\begin{algorithm}[!ht]
	\caption{ntHash2: Spaced Seed Hashing Procedure}
	\label{alg:ntHash2}
	
	\SetKwFunction{FParse}{parse\_seed}
	\Fn{\FParse{$Q$}}{
		$blocks$, $monomers$, $start$, $is\_block \gets \{\}$, $\{\}$, $0$, \KwTrue\;
		\For{$i \gets 0$ \KwTo $s(Q) - 1$}{
			\If{$i \in Q$ \KwAnd $is\_block = $ \KwFalse}{
				$is\_block \gets true$\;
				$start \gets i$\;
			}
			\ElseIf{$i \not\in Q$ \KwAnd $is\_block = $ \KwTrue}{
				\If{$i - start > 1$}{
					$blocks \gets blocks \cup \{ \langle start,\; i \rangle \}$\;
				}
				\Else{
					$monomers \gets monomers \cup \{ i \}$\;
				}
				$is\_block \gets false$\;
			}
		}
		\KwRet{$blocks$, $monomers$}\;
	}
	
	\SetKwFunction{FBase}{base\_hash}
	\Fn{\FBase{$x$, $s(Q)$, $blocks$, $monomers$}}{
		\For{$\langle p,\; q \rangle \in blocks$}{
			\For{$i \gets p$ \KwTo $q$}{
				$h \gets h \oplus \srol^{s(Q) - i - 1} h(x[i])$\;
				$h^{'} \gets h^{'} \oplus \srol^{i} h(x[i] + d)$\tcc*{$d$ is the offset for the complementary bases}
			}
		}
		$h_b,\; h_b^{'} \gets h,\; h^{'}$\;
		\For{$i \in monomers$}{
			$h \gets h \oplus \srol^{s(Q) - i - 1} h(x[i])$\;
			$h^{'} \gets h^{'} \oplus \srol^{i} h(x[i] + d)$\;
		}
		\KwRet{$hash\_results \gets \langle h,\; h^{'},\; h_b,\; h_b^{'} \rangle$}\;
	}
	
	\SetKwFunction{FSlide}{slide\_hash}
	\Fn{\FSlide{$x$, $s(Q)$, $blocks$, $monomers$, $hash\_results$}}{
		$h_b \gets \srol^1 h_b$\;
		\For{$\langle p,\; q \rangle \in blocks$}{
			$h_b \gets h_b \oplus \srol^{s(Q) - p} h(x[p]) \oplus \srol^{s(Q) - q} h(x[q])$\;
			$h_b^{'} \gets h_b^{'} \oplus \srol^{p} h(x[p] + d) \oplus \srol^{q} h(x[q] + d)$\;
		}
		$h_b^{'} \gets \sror^1 h_b^{'}$\;
		$h,\; h^{'} \gets h_b,\; h_b^{'}$\;
		\For{$i \in monomers$}{
			$h \gets h \oplus \srol^{s(Q) - i - 1} h(x[i])$\;
			$h^{'} \gets h^{'} \oplus \srol^{i} h(x[i] + d)$\;
		}
	}
\end{algorithm}
