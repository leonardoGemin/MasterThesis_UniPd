\section{ISSH}
\label{sec:ISSH}

L'algoritmo di \ac{ISSH} \cite{petrucci2020issh} è nato come risposta alla richiesta di una maggiore ottimizzazione del software di \acs{FSH}. Quest'ultimo, infatti, riutilizza parte di un precedente hash value per ri-leggere e codificare nuovamente meno simboli possibili. Con il nuovo algoritmo, \acs{ISSH}, gli autori hanno cercato di ridurre ulteriormente il numero di simboli da rileggere ad un'unico simbolo. Questo è stato fatto utilizzando non solo l'hash precedente che massimizza il numero di simboli da riutilizzare, ma combinando l'utilizzo di più hash precedenti che, insieme, coprono la quasi totalità di simboli che compongono il nuovo $Q$-gram.

È necessario introdurre una nuova definizione di $\mathcal{C}_{g,\; j}$ che definisce le posizioni di $Q$ che, dopo $j$ shift, continuano ad essere in $Q$ con la proprietà che le posizioni $k$ e $k + j$ appartengono entrambe a $Q$ e sono separate da $j - g - 1$ (non necessariamente consecutivi) caratteri \texttt{1}: \[ \mathcal{C}_{g,\; j} = \{ k \in Q \;|\; k + j \in Q \wedge m(k) = m(k + j) - m(j) + m(g) \}. \] L'insieme $\mathcal{C}_{0,\; j}$ corrisponde alla definizione di $\mathcal{C}_j$ fornita da \citeauthor*{girotto2018fsh} in \citetitle{girotto2018fsh} \cite{girotto2018fsh}. Questo perché nell'algoritmo \acs{FSH} si prende sempre come punto di partenza la posizione $0$ di $h(x[j + Q])$.

\begin{example}
	Sia $Q = \{ 0, 1, 2, 4, 6, 8 \}$ lo spaced seed \texttt{11101010101}. In questo esempio viene mostrato il calcolo di $\mathcal{C}_{0,\; 2}$ per il calcolo di $h(x[2 + Q])$, essendo già stato calcolato in precedenza $h(x[0 + Q])$.
	
	\begin{center}
		\begin{tabular}{r || cc|ccccccc|cc}
			$k$ & & & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
			\midrule
			$Q$ & & & \texttt{1} & \texttt{1} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} \\
			$m(k)$ & & & 0 & 1 & 2 & 3 & 3 & 4 & 4 & 5 & 5 \\
			\midrule
			$Q <\!< 2$ & \texttt{1} & \texttt{1} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & & \\
			$m(k + 2)$ & 0 & 1 & 2 & 3 & 3 & 4 & 4 & 5 & 5 & & \\
			\midrule
			%$Q$ & & & \texttt{1} & \texttt{1} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} \\
			%$Q <\!< 2$ & \texttt{1} & \texttt{1} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & & \\
			$(k \in Q) \wedge (k + 2 \in Q)$ & & & T & F & T & F & T & F & T & & \\
			\midrule
			%$m(k)$ & & & 0 & 1 & 2 & 3 & 3 & 4 & 4 & 5 & 5 \\
			$m(k + 2) - m(2) + m(0)$ & -2 & -1 & 0 & 1 & 1 & 2 & 2 & 3 & 3 & & \\
			$m(k) = m(k + 2) - m(2) + m(0)$ & & & T & T & F & F & F & F & F & & \\
			\midrule
			$\mathcal{C}_{0,\; 2}$ & & & 0 & & & & & & & & \\
		\end{tabular}
	\end{center}
	
	Quindi l'unica posizione recuperabile da $h(x[0 + Q])$ è $\mathcal{C}_{0,\; 2} = \{ 0 \}$.
	
	Se, invece, venisse saltata la prima posizione di $h(x[0 + Q])$ e si considerasse l'hash a partire dalla sua seconda posizione, si otterrebbe $\mathcal{C}_{1,\; 2}$:
	
	\begin{center}
		\begin{tabular}{r || cc|ccccccc|cc}
			$k$ & & & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
			\midrule
			$Q$ & & & \texttt{1} & \texttt{1} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} \\
			$m(k)$ & & & 0 & 1 & 2 & 3 & 3 & 4 & 4 & 5 & 5 \\
			\midrule
			$Q <\!< 2$ & \texttt{1} & \texttt{1} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & & \\
			$m(k + 2)$ & 0 & 1 & 2 & 3 & 3 & 4 & 4 & 5 & 5 & & \\
			\midrule
			%$Q$ & & & \texttt{1} & \texttt{1} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} \\
			%$Q <\!< 2$ & \texttt{1} & \texttt{1} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & & \\
			$(k \in Q) \wedge (k + 2 \in Q)$ & & & T & F & T & F & T & F & T & & \\
			\midrule
			%$m(k)$ & & & 0 & 1 & 2 & 3 & 3 & 4 & 4 & 5 & 5 \\
			$m(k + 2) - m(2) + m(1)$ & -1 & 0 & 1 & 2 & 2 & 3 & 3 & 4 & 4 & & \\
			$m(k) = m(k + 2) - m(2) + m(1)$ & & & F & F & T & T & T & T & T & & \\
			\midrule
			$\mathcal{C}_{1,\; 2}$ & & & & & 2 & & 4 & & 6 & & \\
		\end{tabular}
	\end{center}
	
	Nell'ultimo caso, il numero di simboli riutilizzabili dall'hash $h(x[0 + Q])$ per produrre l'hash $h(x[2 + Q])$ aumenta, essendo $\mathcal{C}_{1,\; 2} = \{ 2, 4, 6 \}$.
\end{example}

Il nuovo algoritmo proposto da \citeauthor*{petrucci2020issh} mira a migliorare l'efficienza del calcolo degli hash utilizzando una tecnica iterativa che, invece di basarsi solo sul miglior hash precedente, considera tutti i precedenti hash per creare una combinazione che copra tutti i simboli necessari per $h(x[i + Q])$, eccetto l'ultimo.

Per questo viene definita la funzione $BestPrev(k,\; Q')$ che restituisce una coppia $(g, j)$ che identifica il miglior hash precedente, $h(x[i - j + Q])$, dal quale è possibile recuperare $|\mathcal{C}_{g,\; j} \cap Q'|$ simboli, dopo aver rimosso i suoi primi $g$ simboli: \[ BestPrev(k,\; Q') = \argmax_{g \in \{ 0, 1, \dots, k - 1 \},\; j \in \{ 1, 2, \dots, k \}} |\mathcal{C}_{g,\; j} \cap Q'|. \] Per l'estrazione dei simboli utili dagli hash precedenti viene definita una maschera, $Mask(g,\; j)$, che filtra le posizioni interessate.

\begin{algorithm}[H]
	\caption{ISSH: Iterative Spaced Seed Hashing}
	\label{alg:ISSH}
	$h_0 \gets \text{compute } h(x[0 + Q])$\;
	%\For{$i \gets 0$ \KwTo $|x| - s(Q)$}{
	%	\If{$(i = 0)$}{
	%		$h_0 \gets \text{compute } h(x[0 + Q])$\;
	%	}
	%	\ElseIf{$i < s(Q)$}{
	\For{$i \gets 1$ \KwTo $|x| - s(Q)$}{
		\If{$i < s(Q)$}{
			$Q' \gets Q$\;
			\While{$|Q'| \neq 1$}{
				$(g,\; j) \gets BestPrev(i,\; Q')$\;
				\If{$|\mathcal{C}_{g,\; j} \cap Q'| = 0$}{
					Exit while\;
				}
				\Else{
					$h_i \gets h_i$ \KwOr $((h_{i - j}$ \KwAnd $Mask(g,\; j)) >\!> (j \cdot \log_2 |\mathcal{A}|))$\;
					$Q' \gets Q' \setminus \mathcal{C}_{g,\; j}$\;
				}
			}
			\ForAll{$k \in Q'$}{
				insert $encode(x_{i + k})$ at position $m(k) \cdot \log_2 |\mathcal{A}|$ of $h_i$\;
			}
		}
		\Else{
			$Q' \gets Q$\;
			\While{$|Q'| \neq 1$}{
				$(g,\; j) \gets BestPrev(s(Q) - 1,\; Q')$\;
				$h_i \gets h_i$ \KwOr $((h_{i - j}$ \KwAnd $Mask(g,\; j)) >\!> (j \cdot \log_2 |\mathcal{A}|))$\;
				$Q' \gets Q' \setminus \mathcal{C}_{g,\; j}$\;
			}
			insert $encode(x_{i + s(Q) - 1})$ at last position of $h_i$\;
		}
	}
\end{algorithm}
