\section{ntHash \& ntHash2: Recursive (Spaced Seed) Hashing for Nucleotide Seqences}
\label{sec:ntHash2}

Il metodo di ntHash \cite{mohamadi2016ntHash} si basa su una funzione ricorsiva, nota come funzione di hash rolling, che calcola il valore hash del $k$-mer corrente $h_i$ a partire dal valore hash del $k$-mer precedente $h_{i - 1}$ attraverso una formula ricorsiva. Per inizializzare il calcolo degli hash, il primo $k$-mer viene calcolato come segue: \[ h_0 = \bigoplus_{j = 0}^{k - 1} \rol^{k - 1 - j} h(x[j]). \] In questa formula, $\rol(\cdot)$ è una rotazione ciclica a sinistra, $\oplus$ è l'operatore OR esclusivo (XOR), e $h(\cdot)$ è una tabella di semi dove i caratteri nucleotidici, $\Sigma = \{ \texttt{A}, \texttt{C}, \texttt{G}, \texttt{T} \}$, sono assegnati a diversi interi casuali a 64 bit.

Il valore hash di ogni $k$-mer successivo viene calcolato ricorsivamente: \begin{align*}
	h_i &= f(h_{i - 1}, x[i + k - 1], x[i - 1]) \\
	&= \rol^1 h_{i - 1} \oplus \rol^0 h(x[i + k - 1]) \oplus \rol^k h(x[i - 1])
\end{align*}

La complessità temporale di ntHash è $O(k + |x|)$, in contrasto con la complessità $O(k \cdot |x|)$ delle funzioni di hash convenzionali.

Per calcolare i valori hash delle sequenze complementari inversi di un $k$-mer, ntHash utilizza una tabella di semi che include gli interi corrispondenti alle basi complementari, permettendo il calcolo efficiente senza invertire effettivamente la sequenza di input: \[ h_i^{'} = \begin{dcases*}
	\bigoplus_{j = 0}^{k - 1} \rol^{j} h((x[j] + d) & \quad if $i = 0$ \\
	\ror^1 h_{i - 1}^{'} \oplus \rol^{k - 1} h(x[i + k - 1] + d) \oplus \ror^1 h(x[i - 1] + d) & \quad otherwise
\end{dcases*} \] dove $d$ è l'offset delle basi complementari nella tabella dei semi. Questa proprietà rende ntHash estremamente utile in applicazioni che richiedono la gestione delle sequenze complementari.


Con l'introduzione di ntHash2 \cite{kazemi2022ntHash2}, l'algoritmo è stato ulteriormente migliorato per gestire spaced seeds. Uno dei principali miglioramenti in ntHash2 è l'introduzione della funzione di rotazione, $\srol$, che suddivide una parola a 64 bit in sotto-parole lunghe $d_0, d_1, \dots, d_{n-1}$-bit ($\sum d_i = 64$ and $\gcd(d_i, d_j) = 1$ $\forall i,\; j$), ruota le sotto-parole separatamente e ne combina i risultati. La periodicità della rotazione suddivisa è pari a $\lcm(d_0, d_1, \dots, d_{n - 1})$, rendendola più adatta per lunghezze di $k$-mer più lunghe. Inoltre, per migliorare la distribuzione uniforme degli hash, ntHash2 definisce il valore hash canonico di ogni seme come la somma del forward hash e del reverse hash, sostituendo la vecchia versione che usava il minimo tra i due valori.

La principale innovazione di ntHash2 è il metodo per l'hashing dei semi spaziati. Anzitutto viene data la definizione di blocco, che è una sotto-sequenza di $Q$ composta di caratteri \texttt{1} consecutivi, delimitata dal carattere \texttt{0} o dai bordi dello spaced seed. Per calcolare il valore hash per i primi $s(Q)$ caratteri, si itera su intervalli di blocchi e si includono i caratteri usando $\srol(\cdot)$ e operazioni XOR con complessità temporale $O(|Q|)$. Gli hash successivi vengono generati rimuovendo e includendo caratteri in base agli indici dei blocchi, con complessità $O(|B|)$. Per un calcolo più rapido, ntHash2 ridefinisce i blocchi come tratti di \texttt{0} se il numero di operazioni XOR previste è inferiore escludendo gli \texttt{0} dal valore hash.

Le funzioni che calcolano l'hashing value ed il suo reverse hashing sono ridefinite secondo queste formule: \[ h_i = \begin{dcases*}
	\bigoplus_{j = 0}^{k - 1} \rol^{k - 1 - j} h(x[j]) & \quad if $i = 0$ \\
	\srol^1 h_{i - 1} \oplus \srol^0 h(x[i + k - 1]) \oplus \srol^k h(x[i - 1]) & \quad otherwise
\end{dcases*} \]

\[ h_i^{'} = \begin{dcases*}
	\bigoplus_{j = 0}^{k - 1} \srol^{j} h((x[j] + d) & \quad if $i = 0$ \\
	\sror^1 h_{i - 1}^{'} \oplus \srol^{k - 1} h(x[i + k - 1] + d) \oplus \sror^1 h(x[i - 1] + d) & \quad otherwise
\end{dcases*} \]

\begin{algorithm}[!ht]
	\caption{ntHash2: Spaced Seed Hashing Procedure}
	\label{alg:ntHash2}
	\SetKwProg{Pn}{Function}{:}{\KwRet}
	
	\SetKwFunction{FParse}{parse\_seed}
	\Pn{\FParse{$Q$}}{
		$blocks$, $monomers$, $start$, $is\_block = \{\}$, $\{\}$, $0$, \KwTrue\;
		\For{$i \gets 0$ \KwTo $s(Q)$}{
			\If{$i \in Q$ \KwAnd $is\_block = $ \KwFalse}{
				$is\_block \gets true$\;
				$start \gets i$\;
			}
			\ElseIf{$i \not\in Q$ \KwAnd $is\_block = $ \KwTrue}{
				\If{$i - start > 1$}{
					$blocks \gets blocks \cup \{ \langle start,\; i \rangle \}$\;
				}
				\Else{
					$monomers \gets monomers \cup \{ i \}$\;
				}
				$is\_block \gets false$\;
			}
		}
		\KwRet{$blocks$, $monomers$}\;
	}
	
	\SetKwFunction{FBase}{base\_hash}
	\Pn{\FBase{$x$, $s(Q)$, $blocks$, $monomers$}}{
		$hash\_results \gets \langle h,\; h^{'},\; h_b,\; h_b^{'} \rangle$\;
		\For{$\langle p,\; q \rangle \in blocks$}{
			\For{$i \gets p$ \KwTo $q$}{
				$h \gets h \oplus \srol^{s(Q) - i - 1} h(x[i])$\;
				$h^{'} \gets h^{'} \oplus \srol^{i} h(x[i] + d)$\;
			}
		}
		$h_b,\; h_b^{'} \gets h,\; h^{'}$\;
		\For{$i \in monomers$}{
			$h \gets h \oplus \srol^{s(Q) - i - 1} h(x[i])$\;
			$h^{'} \gets h^{'} \oplus \srol^{i} h(x[i] + d)$\;
		}
		\KwRet{$hash\_results$}\;
	}
	
	\SetKwFunction{FSlide}{slide\_hash}
	\Pn{\FSlide{$x$, $s(Q)$, $blocks$, $monomers$, $hash\_results$}}{
		$h_b \gets \srol^1 h_b$\;
		\For{$\langle p,\; q \rangle \in blocks$}{
			$h_b \gets h_b \oplus \srol^{s(Q) - p} h(x[p]) \oplus \srol^{s(Q) - q} h(x[q])$\;
			$h_b^{'} \gets h_b^{'} \oplus \srol^{p} h(x[p] + d) \oplus \srol^{q} h(x[q] + d)$\;
		}
		$h_b^{'} \gets \sror^1 h_b^{'}$\;
		$h,\; h^{'} \gets h_b,\; h_b^{'}$\;
		\For{$i \in monomers$}{
			$h \gets h \oplus \srol^{s(Q) - i - 1} h(x[i])$\;
			$h^{'} \gets h^{'} \oplus \srol^{i} h(x[i] + d)$\;
		}
		\KwRet\;
	}
\end{algorithm}
